Библиотека содержит в себе описание классов и встроенную ORM

Идея библиотеки заключается в том, что бы описать лишь структуру PHP классов указав зависимости между ними и какой таблицой базы пользуется каждый из них, а со стороны Mysq указать вторичные ключи (связи между таблицами).

Это позволить отказаться от "лапшакода" описывающим сохранение и загрузку данных, сосредоточив внимание лишь на данных (и обновлять легко - изменить лишь в каласса поле и в БД).

Для реализации автоматического сохранение объектов (с передачей потомкам вторичных Primary ID родлителей) в бд и так же из загрузка по цепочки карты состоящей из разных объектов было использовани

	Reflection
	Атрибуты PHP (в коде выглядят как коментарии с #.... где указвается класс)
	Typehint свойств классов
	Mysql команды (просмотр вторичных ключей таблицы данного класса)

На базе этого сделаны плагины отвечающие принципу барбары Лисков и разделения логики (SOLID) по парсингу XML (где свойство класса PHP типа массив или оюъект - это тег xml, все остальное - атрибуты элемента xml) и сбор из классов изображений (библиотека GD)

Для полее подробного понимания как работает библиотека:

	если вам необходима закгрузка класса и всех дочерних к нему свйоств-классов с атрибутами (см описание ниже) из ассоциативного массива из Бд (через метод load())- в конструкторе объявляем свойства класса одноименно с названием полей в бд и тем же типом  (см Php8 объявление свойств в констркуторе). незабудьте вызвать parent::__construct() 

	при вызове метода load() рекурсивно загружается из бд и все его дочерние элементы (свойства что описаны в п 3) - тоже (программа вызывает метод keys(<название атрибута REFLECTION>) смотрит контстанту TABLE и по вторичным ключам понимает какие нужно передать в контсрern параметры от родителя. если TABLE нет - такое тоже возмоможно когда надо создать промежуточный клас, скажем который превратит из объекта в массивы объектов данные произведя манипуляции - например LayerData который explode делает данных xml элемента - то смотрит все свойства объявленные через констурктор дочернего элемента , сравниивает что есть в родителе - и передает в контструктор и тогда - если есть связь - в нем так же вызывается load ко всем дочерним уже к нему свойтвам )
 
	Имеется статический метод get (получение) и update (обновление) данных  - их можно переопределить если сохранение данных требует манипуляций (что редко, тк манипуляции делаются при переопределении методой save() и load())

	При сохранении текущего объекта проверяется есть ли контстанта TABLE у текущего класса  (те таблица куда будут записаны распарсеные данные). Если есть - сохранит в базу те поля что объявлены в конструткоре. 
	
	При сохранении (метод save() ) дочерних объектов (Reflection  сам соберет все обекъты и массивы в текущем классе) программа так же смотрит есть ли у констатнта TABLE и есть ли у объекта метод save. Если есть TABLE - запросить какие у таблицы дочернего объекта вторичные ключи, проверит есть ли такие в текущем объекте (как минимум один у вас должен быть чисто логически если вы парсите дочерние элементы их должно связывать что то с текущим) передаст их дочернему объекту перед его сохранением. Если же TABLE нет то проверит есть ли у текущего AUTO_INCREMENT, есть ли у дочернего объекта свойство с таким же названием и передаст только его

	Если есть TABLE - запросить какие у таблицы дочернего объекта вторичные ключи, проверит есть ли такие в текущем объекте (как минимум один у вас должен быть чисто логически если вы парсите дочерние элементы их должно связывать что то с текущим) передаст их дочернему объекту перед его сохранением. Если же TABLE нет то проверит есть ли у текущего AUTO_INCREMENT, есть ли у дочернего объекта свойство с таким же названием и передаст только его

	Можно переопредлелять логику работы в частности создавая в отдельной папке одноименные классы и делать extend от родителеьских и указывая другйо namespace и вызывать при старте класс Map(...) в нужном namespace , при этом при загрузке методом load()  программа будет создавать объекты  на свойства свйоства класса (где атрибуты  REFLECTION имеются)  уже в рамках классов текузего namespace (если таковые есть. если нет - возьмет родительские, те нет нужды пересоздавать все классы родительские , а только те чт хотим переопределить)

	Подобным образом сделан плагин GD , что после load()  собирает ресурс изображений
	
	Подорбным образом сделан deserialize который использует структуру родительских классов и атрибуты REFLECTION, но в данном случае они же и являются xml тегами и свойствами xml документа, так же добавляет метод desirilize работающий аналогично load создавая ексземпляры классов этих атрибутов REFLECTION  передавая туда xml для дальнейшего разбора и присвоение данных свойствам объекту 

