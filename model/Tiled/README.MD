1. если вам необходима закгрузка класса и всех дочерних к нему свйоств-классов с атрибутами (см описание ниже) из ассоциативного массива из Бд (через метод load())- в конструкторе объявляем свойства класса одноименно с названием полей в бд и тем же типом  (см Php8 объявление свойств в констркуторе). незабудьте вызвать parent::__construct() 

при вызове метода load() рекурсивно загружается из бд и все его дочерние элементы (свойства что описаны в п 3) - тоже (программа вызывает метод keys(<название атрибута REFLECTION>) смотрит контстанту TABLE и по вторичным ключам понимает какие нужно передать в контсрern параметры от родителя. если TABLE нет - такое тоже возмоможно когда надо создать промежуточный клас, скажем который превратит из объекта в массивы объектов данные произведя манипуляции - например LayerData который explode делает данных xml элемента - то смотрит все свойства объявленные через констурктор дочернего элемента , сравниивает что есть в родителе - и передает в контструктор и тогда - если есть связь - в нем так же вызывается load ко всем дочерним уже к нему свойтвам )
 
Имеется статический метод get


При сохранении текущего объекта проверяется есть ли контстанта TABLE у текущего класса  (те таблица куда будут записаны распарсеные данные). Если есть - сохранит в базу те поля что объявлены в конструткоре. 
При сохранении (метод save() ) дочерних объектов (Reflection  сам соберет все обекъты и массивы в текущем классе) программа так же смотрит есть ли у констатнта TABLE и есть ли у объекта метод save. Если есть TABLE - запросить какие у таблицы дочернего объекта вторичные ключи, проверит есть ли такие в текущем объекте (как минимум один у вас должен быть чисто логически если вы парсите дочерние элементы их должно связывать что то с текущим) передаст их дочернему объекту перед его сохранением. Если же TABLE нет то проверит есть ли у текущего AUTO_INCREMENT, есть ли у дочернего объекта свойство с таким же названием и передаст только его

Если есть TABLE - запросить какие у таблицы дочернего объекта вторичные ключи, проверит есть ли такие в текущем объекте (как минимум один у вас должен быть чисто логически если вы парсите дочерние элементы их должно связывать что то с текущим) передаст их дочернему объекту перед его сохранением. Если же TABLE нет то проверит есть ли у текущего AUTO_INCREMENT, есть ли у дочернего объекта свойство с таким же названием и передаст только его



Можно переопредлелять логику работы в частности создавая в отдельнйо папке одноименные классы и делать extend от родителеьских и указывая другйо namespace и вызывать при старте класс Map(...) в нужном namespace , при этом при загрузке методом load()  программа будет создавать объекты  на свойства свйоства класса (где атрибуты  REFLECTION имеются)  уже в рамках классов текузего namespace (если таковые есть. если нет - возьмет родительские, те нет нужды пересоздавать все классы родительские , а только те чт хотим переопределить)

Подобным образом сделан плагин GD , что после load()  собирает ресурс изображений
Подорбным образом сделан deserialize который использует структуру родительских классов и атрибуты REFLECTION, но в данном случае они же и являются xml тегами и свойствами xml документа, так же добавляет метод desirilize работающий аналогично load создавая ексземпляры классов этих атрибутов REFLECTION  передавая туда xml для дальнейшего разбора и присвоение данных свойствам объекту 

